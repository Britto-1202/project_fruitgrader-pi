import cv2
import numpy as np
import pandas as pd
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.utils import COMMASPACE
from email import encoders

# Load the pre-trained ML model
model = tf.keras.models.load_model('fruits_datas .h5')

# Set the threshold for fruit detection
threshold = 0.5

# Define a dictionary to map indices to fruit labels
label_dict = {0: "fresh apple", 1: "fresh banana", 2: "fresh orange",
              3: "rotten apple", 4: "rotten banana", 5: "rotten orange"}

# Start capturing video from webcam
cap = cv2.VideoCapture(0)

# Set the frame size
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Initialize empty lists to store results
results = []
images = []

while True:
    # Read a frame from the video stream
    ret, frame = cap.read()

    # Display the original frame
    cv2.imshow('Fruit Detector', frame)

    # Wait for key press
    key = cv2.waitKey(1)
    if key == ord('q'):
        # Save results to CSV file and send email with attachments
        df = pd.DataFrame(results, columns=['Image', 'Prediction'])
        df.to_csv('fruit_predictions.csv', index=False)
        
        # Compose email with attachments
        sender = 'sender@gmail.com'
        sender_password = 'sender_password'
        recipients = ['recipient1@gmail.com', 'recipient2@gmail.com']
        msg = MIMEMultipart()
        msg['From'] = sender
        msg['To'] = COMMASPACE.join(recipients)
        msg['Subject'] = 'Fruit Predictions'
        msg.attach(MIMEText('Please find the attached fruit predictions CSV file and image folder.'))
        for file_path in ['fruit_predictions.csv', 'fruit_images.zip']:
            with open(file_path, "rb") as f:
                part = MIMEBase('application', 'octet-stream')
                part.set_payload(f.read())
                encoders.encode_base64(part)
                part.add_header('Content-Disposition', 'attachment', filename=file_path)
                msg.attach(part)
        
        # Send email with attachments
        with smtplib.SMTP('smtp.gmail.com', 587) as smtp:
            smtp.starttls()
            smtp.login(sender, sender_password)
            smtp.send_message(msg)
            print('Email sent with attachments.')
        
        # Exit the loop
        break
        
    elif key == ord(' '):
        # Capture the image and save it to a file
        fruit = frame
        cv2.imwrite(f'fruit_images/{len(images)}.jpg', fruit)
        images.append(f'fruit_images/{len(images)}.jpg')

        # Preprocess the image for the ML model
        img = tf.keras.preprocessing.image.img_to_array(fruit)
        img = tf.keras.preprocessing.image.smart_resize(img, (224, 224))
        img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

        # Pass the image to the ML model and get the prediction
        preds = model.predict(np.expand_dims(img, axis=0))
        print(preds)

        # Get the index of the maximum value in the preds array
        pred_index = np.argmax(preds)
        print(pred_index)
        #


import cv2
import numpy as np
import pandas as pd
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
import tensorflow as tf

# Load the pre-trained ML model
model = tf.keras.models.load_model('fruits_datas .h5')

# Start capturing video from webcam
cap = cv2.VideoCapture(0)

# Set the frame size
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Define a dictionary to map indices to fruit labels
label_dict = {0: "fresh apple", 1: "fresh banana", 2: "fresh orange",
              3: "rotten apple", 4: "rotten banana", 5: "rotten orange"}

# Define the threshold for fruit classification
threshold = 0.5

# Define the email addresses
sender_address = 'your_email_address'
sender_password = 'your_email_password'
receiver_address = 'recipient_email_address'

# Define the subject and body of the email
subject = 'Fruit Detection Results'
body = 'Please see the attached results.'

while True:
    # Read a frame from the video stream
    ret, frame = cap.read()

    # Display the original frame
    cv2.imshow('Fruit Detector', frame)

    # Wait for key press
    key = cv2.waitKey(1)
    if key == ord('q'):
        break
    elif key == ord(' '):
        # Capture the image and save it to a file
        fruit = frame
        cv2.imwrite('fruit.jpg', fruit)

        # Preprocess the image for the ML model
        img = tf.keras.preprocessing.image.img_to_array(fruit)
        img = tf.keras.preprocessing.image.smart_resize(img, (224, 224))
        img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

        # Pass the image to the ML model and get the prediction
        preds = model.predict(np.expand_dims(img, axis=0))

        # Get the index of the maximum value in the preds array
        pred_index = np.argmax(preds)

        # Check if the predicted class is above the threshold
        if preds[0][pred_index] > threshold:
            # Get the corresponding fruit label from the dictionary
            label = label_dict[pred_index]
            print(f"The fruit is a {label}.")

            # Add the fruit image and label to a CSV file
            df = pd.read_csv('fruit_results.csv')
            df = df.append({'Fruit': label, 'Image': 'fruit.jpg'}, ignore_index=True)
            df.to_csv('fruit_results.csv', index=False)

            # Create a message with an image attachment
            msg = MIMEMultipart()
            msg['From'] = sender_address
            msg['To'] = receiver_address
            msg['Subject'] = subject
            msg.attach(MIMEText(body))
            img_data = open('fruit.jpg', 'rb').read()
            image = MIMEImage(img_data, name='fruit.jpg')
            msg.attach(image)

            # Send the email
            smtp_server = smtplib.SMTP('smtp.gmail.com', 587)
            smtp_server.starttls()
            smtp_server.login(sender_address, sender_password)
            smtp_server.sendmail(sender_address, receiver_address, msg.as_string())
            smtp_server.quit()

        else:
            print("Please show a valid image.")

# Release the capture and destroy all windows
cap.release()
cv2.destroyAllWindows()


import cv2
import numpy as np
import tensorflow as tf
import os
import csv
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage

# Load the pre-trained ML model
model = tf.keras.models.load_model('fruits_datas .h5')

# Start capturing video from webcam
cap = cv2.VideoCapture(0)

# Set the frame size
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Create a folder to store the images
if not os.path.exists('fruit_images'):
    os.makedirs('fruit_images')

# Create a CSV file to store the image filenames and labels
with open('fruit_labels.csv', mode='w', newline='') as csv_file:
    fieldnames = ['filename', 'label']
    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)

    writer.writeheader()

    while True:
        # Read a frame from the video stream
        ret, frame = cap.read()

        # Display the original frame
        cv2.imshow('Fruit Detector', frame)

        # Wait for key press
        key = cv2.waitKey(1)
        if key == ord('q'):
            break
        elif key == ord(' '):
            # Capture the image and save it to a file
            filename = f"fruit_images/fruit_{len(os.listdir('fruit_images')) + 1}.jpg"
            cv2.imwrite(filename, frame)

            # Preprocess the image for the ML model
            img = tf.keras.preprocessing.image.img_to_array(frame)
            img = tf.keras.preprocessing.image.smart_resize(img, (224, 224))
            img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

            # Pass the image to the ML model and get the prediction
            preds = model.predict(np.expand_dims(img, axis=0))
            print(preds)

            # Define a dictionary to map indices to fruit labels
            label_dict = {0: "fresh apple", 1: "fresh banana", 2: "fresh orange",
                          3: "rotten apple", 4: "rotten banana", 5: "rotten orange"}

            # Get the index of the maximum value in the preds array
            pred_index = np.argmax(preds)
            print(pred_index)
            # Check if the predicted class is above the threshold
            if preds[0][pred_index] > 0.5:
                # Get the corresponding fruit label from the dictionary
                label = label_dict[pred_index]
                print(f"The fruit is a {label}.")
                writer.writerow({'filename': filename, 'label': label})
            else:
                print("Please show a valid image.")

    # Close the CSV file
    csv_file.close()

# Release the capture and destroy all windows
cap.release()
cv2.destroyAllWindows()

# Create a message with the CSV file attached
msg = MIMEMultipart()
msg['Subject'] = 'Fruit Images'
msg['From'] = 'sender@example.com'
msg['To'] = 'recipient@example.com'

with open('fruit_labels.csv', 'rb') as f:
    file_data = f.read()

msg.attach(MIMEText('Please find the attached CSV file with the list of fruit images.'))
msg.attach(MIMEImage(file_data, name='fruit_labels.csv'))

# Send the email
with smtplib.SMTP('smtp.gmail.com', 587)
import cv2
import os
import zipfile
import smtplib
from email.message import EmailMessage

# Set up the email parameters
from_email = 'your_email@example.com'
from_password = 'your_email_password'
to_email = 'recipient_email@example.com'

# Set up the folder for saving the images
image_folder = 'fruit_images'
if not os.path.exists(image_folder):
    os.mkdir(image_folder)

# Start capturing video from webcam
cap = cv2.VideoCapture(0)

# Set the frame size
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Define the crop region for the fruit
x, y, w, h = 200, 100, 200, 200

while True:
    # Read a frame from the video stream
    ret, frame = cap.read()

    # Display the original frame
    cv2.imshow('Fruit Detector', frame)

    # Wait for key press
    key = cv2.waitKey(1)
    if key == ord('q'):
        break
    elif key == ord(' '):
        # Capture the image and save it to a file
        fruit = frame[y:y+h, x:x+w]
        image_filename = os.path.join(image_folder, f'fruit_{len(os.listdir(image_folder))+1}.jpg')
        cv2.imwrite(image_filename, fruit)

        # Preprocess the image for the ML model
        img = tf.keras.preprocessing.image.img_to_array(fruit)
        img = tf.keras.preprocessing.image.smart_resize(img, (224, 224))
        img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

        # Pass the image to the ML model and get the prediction
        preds = model.predict(np.expand_dims(img, axis=0))

        # Define a dictionary to map indices to fruit labels
        label_dict = {0: "fresh apple", 1: "fresh banana", 2: "fresh orange",
                      3: "rotten apple", 4: "rotten banana", 5: "rotten orange"}

        # Get the index of the maximum value in the preds array
        pred_index = np.argmax(preds)

        # Check if the predicted class is above the threshold
        if preds[0][pred_index] > 0.5:
            # Get the corresponding fruit label from the dictionary
            label = label_dict[pred_index]

            # Increment the counter for the appropriate label
            if 'fresh' in label:
                fresh_count += 1
            else:
                rotten_count += 1

            # Print the label and confidence score
            print(f'Label: {label}, Confidence: {preds[0][pred_index]}')

            # Save the results to the CSV file
            with open(csv_filename, mode='a', newline='') as csv_file:
                writer = csv.writer(csv_file)
                writer.writerow([image_filename, label, preds[0][pred_index]])

# Release the webcam and close all windows
cap.release()
cv2.destroyAllWindows()

# Create a zip archive of the image folder
zip_filename = 'fruit_images.zip'
with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zip_file:
    for root, dirs, files in os.walk(image_folder):
        for file in files:
            zip_file.write(os


import cv2
import os
import zipfile
import smtplib
from email.message import EmailMessage

import tensorflow as tf
import numpy as np
import csv

# Load the trained ML model
model = tf.keras.models.load_model('fruit_classifier.h5')

# Set up the email parameters
from_email = 'your_email@example.com'
from_password = 'your_email_password'
to_email = 'recipient_email@example.com'

# Set up the folder for saving the images
image_folder = 'fruit_images'
if not os.path.exists(image_folder):
    os.mkdir(image_folder)

# Set up the CSV file for saving the results
csv_filename = 'fruit_results.csv'
with open(csv_filename, mode='w', newline='') as csv_file:
    writer = csv.writer(csv_file)
    writer.writerow(['Image File', 'Label', 'Confidence'])

# Set up the counters for fresh and rotten fruits
fresh_count = 0
rotten_count = 0

# Start capturing video from webcam
cap = cv2.VideoCapture(0)

# Set the frame size
cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)

# Define the crop region for the fruit
x, y, w, h = 200, 100, 200, 200

while True:
    # Read a frame from the video stream
    ret, frame = cap.read()

    # Display the original frame
    cv2.imshow('Fruit Detector', frame)

    # Wait for key press
    key = cv2.waitKey(1)
    if key == ord('q'):
        # Create a zip archive of the image folder
        zip_filename = 'fruit_images.zip'
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for root, dirs, files in os.walk(image_folder):
                for file in files:
                    zip_file.write(os.path.join(root, file))

        # Send an email with the results and the image folder zip archive
        msg = EmailMessage()
        msg['Subject'] = 'Fruit Detection Results'
        msg['From'] = from_email
        msg['To'] = to_email
        msg.set_content(f'Fresh fruits: {fresh_count}, Rotten fruits: {rotten_count}')

        with open(csv_filename, 'rb') as csv_file:
            csv_data = csv_file.read()
            msg.add_attachment(csv_data, maintype='text', subtype='csv', filename=csv_filename)

        with open(zip_filename, 'rb') as zip_file:
            zip_data = zip_file.read()
            msg.add_attachment(zip_data, maintype='application', subtype='zip', filename=zip_filename)

        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:
            smtp.login(from_email, from_password)
            smtp.send_message(msg)

        break
    elif key == ord(' '):
        # Capture the image and save it to a file
        fruit = frame[y:y+h, x:x+w]
        image_filename = os.path.join(image_folder, f'fruit_{len(os.listdir(image_folder))+1}.jpg')
        cv2.imwrite(image_filename, fruit)

        # Preprocess the image for the ML model
        img = tf.keras.preprocessing.image.img_to_array(fruit)
        img = tf.keras.preprocessing.image.smart_resize(img, (224, 224))
        img = tf.keras.applications.mobilenet_v2.preprocess_input(img)

        # Pass the image to the ML model and get the prediction
        preds = model.predict(np.expand_dims(img, axis=0))

        # Define
